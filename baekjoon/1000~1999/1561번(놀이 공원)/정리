[방법1.]
결정 문제 => K번 놀이기구에 탑승이 가능한가?
-> 탑승이 가능하면 더 작은 쪽으로 가야함
<이렇게 하면 생기는 문제>
탑승이 불가능할 경우 갈 곳이 없음

[방법2.]
시간순으로 계속 정렬
결정 문제 => K번 놀이기구의 시간이 0인가?
-> 0이 아니면 더 작은 쪽으로 가기, 이렇게 해서 가장 작은 쪽으로 가면 그 놀이기구 탑승가능
<이렇게 하면 생기는 문제>
정렬을 할 때, 인덱스 번호를 가지고 가야하는데 이러면 2차원 리스트가 되버림 -> 시간이 많이 든다
0으로 정렬을 할꺼면 사실 이분 탐색을 할 필요가 없음, 람다로 정렬해서 가장 앞에 있는 놀이기구 번호 쓰면 됨



이분탐색은 정렬이 되어 있는 리스트에서 사용이 가능함
무언가를 정렬 시킬때마다 NlogN이라는 시간이 듬
즉, 정렬을 하지 않고 이분탐색이 가능해야 시간적으로 여유로움
물론 절대적인 것은 아님, 정렬을 할 수도 있음
정렬을 하지 않으려면 위의 [방법2.]같은 것은 하면 안됨
순번으로 이분탐색을 진행해야하는데, 놀이기구로 하면 무지성 작은 쪽으로 가는거 밖에 없음
=> 아이들로 이분탐색을 해야한다

[방법3.]
이분탐색의 주체는 아이들이 됨
결정문제 => 너 놀이기구 탔니?
-> 놀이기구를 탔으면 큰쪽으로 안탔으면 작은쪽으로 가면됨
<이렇게 하면 생기는 문제>
아이들의 최대값은 20억임. 즉, 아이들 리스트만 만들어도 빅오는 20억임
==> 해결법은 비트마스킹
? 이렇게 할빠엔, 그냥 처음부터 인덱스를 기록해서 가는게 더 시간이 적게걸림 => [방법3.]은 위치를 찾는데 logN이라는 시간이 들지만
그냥 찾으면 1임


[방법4.]
이거 패턴이 있음, 무언가의 배수 + 알파임
즉, 학생의 수가 20억까지 있지만, 어느 수 이상부터는 같은 패턴의 반복임
패턴을 찾고 그 패턴에서 학생의 수로 나눈 후 나머지가 답
<이렇게 하면 생기는 문제>
패턴은 조합임 10000C3만 되도 시간이 부족해짐


[방법5.]
내가 DP를 풀 때 쓰는 방법으로 하나하나씩 하기
파라메틱 서치는 최적화 문제를 결정 문제로 바꾸는 것
1. 최적화 문제 -> ??
2. 결정 문제 -> 마지막 아이가 타게될 놀이기구의 번호가 K번 인가요?