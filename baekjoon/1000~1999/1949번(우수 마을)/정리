트리 + DP
=> 보통의 경우 탑 다운이다
=> 먼저 리프 노드 까지간다
   그 후, 백트랙하면서 정답을 구하면 된다

DP란?
문제를 가장 작은 단위로 쪼개서 계산을 한다. 이 과정에서 이전에 계산한 것을 이용해서 시간을 줄인다.

트리란?
사이클이 없는 그래프로, 간선의 수는 (노드 수) - 1이다. 또한 모든 노드는 연결되어 있다.

트리 + DP란?
트리 자료구조에서 하는 DP로, 특정 노드를 루트 노드로 하는 서브 트리에서의 값을 보는 것

이 문제의 가장 작은 단위
1번 노드를 루트 노드로 하는 서브 트리의 최대값 => 2번 노드의 최대값
2번 노드를 루트 노드로 하는 서브 트리의 최대값 => 3번, 6번 노드의 최대값
3번 노드를 루트 노드로 하는 서브 트리의 최대값 => 4번 노드의 최대값
4번 노드를 루트 노드로 하는 서브 트리의 최대값 => 5번 노드의 최대값 -> 가장 작은 단위
6번 노드를 루트 노드로 하는 서브 트리의 최대값 => 7번 노드의 최대값 -> 가장 작은 단위


[방법 1.]
1. 무조건 리프 노드까지 들어감
=> 조건에서 인접한 마을이 "우수 마을"이면 안되고, 인접한 마을에 "우수 마을"이 없으면 안됨
   즉, 리프 노드 or 그 리프 노드의 부모 노드는 무조건 "우수 마을"임
   이 경우에서 리프 노드가 더 크면 리프 노드는 "우수 마을"임
   하지만, 부모 노드가 더 크다고 해서 "우수 마을"은 아님
2. 각 노드에 각 노드까지 오면서 걸린 값 중 최대값을 저장함
3. 루트 노드에 갈 때까지 이 값을 계속 갱신함 => 루트 노드의 값이 정답임

[방법 2.] => 이게 정답
문제에서 상태가 2개임, "우수 마을"과 "일반 마을"
그렇다면, 루트 노드가 "우수 마을"일 때의 최대값과, "일반 마을"일 때의 최대값을 구하면 됨
dp[idx][우수 마을 = 0] = max( 현재 노드의 인구수, 현재 상태) + dp[자식 노드][1]
dp[idx][일반 마을 = 1] = max( dp[자식 노드][0], dp[자식 노드][1]) + 현재 상태
