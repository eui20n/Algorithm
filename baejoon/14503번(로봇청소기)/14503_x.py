# 로봇청소기
# 로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하라
# 로봇 청소기는 아래와 같이 작동한다
# 1. 현재 위치를 청소한다
# 2. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향부터 차례대로 인접한 칸을 탐색한다
# 2-1. 왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번주터 진행
# 2-2. 왼쪽 방향에 청소할 공간이 없다면 그 방향으로 회전하고 2번으로 돌아간가
# 2-3. 네 방향 모두 청소가 이미 되어있거나 벽인 경우, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다
# 2-4. 네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우 작동을 멈춘다
# 로봇 청소기는 이미 청소되어 있는 칸을 또 청소하지 않으며, 벽을 넘을 수 없다
# 입력은 청소하는 곳의 크기, 로봇청소기의 위치와 방향, 그 다음은 청소해야하는 곳의 상태가 주어진다
# 0은 빈칸, 1은 벽이다, 지도의 첫행, 마지막행, 첫열, 마지막열은 모두 벽이다
# 0 - 북쪽, 1 - 동쪽, 2 - 남쪽, 3 - 서쪽
from collections import deque

N,M = map(int,input().split())
r,c,d = map(int,input().split())
graph = [list(map(int,input().split())) for _ in range(N)]


# 4방향을 보는게 아님, 무조건 앞으로 감
# 이 방향 벡터는 탐색할 곳임, 왼쪽을 먼저 보기때문에 첫번째는 북쪽기준 왼쪽을 본것임
# 방향 인덱스 부터 가면 됨 -> 서 북 동 남
dx = [0,1,0,-1,0,1,0,-1]
dy = [-1,0,1,0,-1,0,1,0]
dir = [3,2,1,0,3,2,1,0]
# 북 0 1 2 3
# 동 3 4 5 6
# 남 2 3 4 5
# 서 1 2 3 4


# 서 남 동 북 서 남 동 북
# 0 3  2  1 

# 북 기준 서 남 동 북
# 동 기준 북 서 남 동
# 남 기준 동 북 서 남
# 서 기준 남 동 북 서

# 뒤로 가는 연산을 위해서 만듬
bx = [1,0,-1,0]
by = [0,-1,0,1]


def bfs(r,c,d):
    q = deque()
    depth = 1
    q.append([r,c,depth,d])
    graph[r][c] = '*'
    while q:
        p = q.popleft()
        if p[3] == 3:
            k = 1
        elif p[3] == 2:
            k = 2
        elif p[3] == 1:
            k = 3
        elif p[3] == 0:
            k = 0
        for z in range(k,4+k):
            nx = p[0] + dx[z]
            ny = p[1] + dy[z]
            if 0 <= nx < len(graph) and 0 <= ny < len(graph[0]):
                if graph[nx][ny] == 0: # 청소할 곳이 있다는 것
                    q.append(([nx,ny,p[2] + 1,dir[z]])) # 방향 설정을 잘못한것 같음
                    graph[nx][ny] = p[2] + 1
                    break # 한 곳만 가면 됨 -> for문 멈춤
                if z == 3 + p[3]: # 4번째 본것, 4 + d - 1
                    # 4방향 모두 다 봤으면 여기서는 현재 방향을 의미하는 것
                    if graph[p[0] + bx[dir[z]]][p[1] + by[dir[z]]] == 1:
                        return p[2]
                    else:
                        q.append([p[0] + bx[p[3]],p[1] + by[p[3]],p[2],dir[z]]) # 그냥 후진 하는 거라서 청소한게 아님 -> depth에 1추가 안함
                        break


# 북쪽일때는 서쪽탐색 [0,-1] 후진 [1,0]
# 동쪽일때는 북쪽탐색 [-1,0] 후진 [0,-1]
# 남쪽일때는 동쪽탐색 [0,1] 후진 [-1,0]
# 서쪽일때는 남쪽탐색 [1,0] 후진 [0,1]

# 방향 다시 생각하기 -> 만약에 다시 생각해도 안되면 그냥 좀 손 아픈 방법으로 하기            
            
print(bfs(r,c,d))
            
            
